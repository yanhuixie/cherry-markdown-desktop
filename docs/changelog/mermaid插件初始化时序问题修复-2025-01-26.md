# Mermaid 插件初始化时序问题修复

**日期**: 2025-01-26
**版本**: 0.1.1
**修复类型**: Bug 修复 + 架构优化

## 问题描述

### 报错信息

在开发模式下，虽然 mermaid 图表能够正常渲染，但控制台报告以下错误：

```
[CherryEditor] Failed to load mermaid plugin: Error: The function `usePlugin` should be called before Cherry is instantiated.
    at t2.value (cherry-markdown.core.js:1:1585595)
    at initMermaidPlugin (CherryEditor.vue:25:12)
    at async initEditor (CherryEditor.vue:144:21)
    at async CherryEditor.vue:526:3
```

### 表现症状

1. **开发模式**：错误提示，但 mermaid 图表能正常渲染
2. **生产构建模式**：mermaid 样式混乱，图表无法正确显示，且出现 CSP 错误：

```
Connecting to 'http://ipc.localhost/plugin%3Awindow%7Ctheme' violates the following Content Security Policy directive: "connect-src 'self' https://api.github.com".
Fetch API cannot load http://ipc.localhost/plugin%3Awindow%7Ctheme. Refused to connect because it violates the document's Content Security Policy.
IPC custom protocol failed, Tauri will now use the postMessage interface instead
```

## 问题调查过程

### 1. 分析 Cherry Markdown 源码

通过阅读 [CherryStatic.js:56-72](D:/Downloads/cherry-markdown-cherry-markdown-0.10.3/packages/cherry-markdown/src/CherryStatic.js#L56-L72)，发现：

```javascript
static usePlugin(PluginClass, ...args) {
  if (this === CherryStatic) {
    throw new Error('`usePlugin` is not allowed to called through CherryStatic class.');
  }
  // @ts-ignore
  if (this.initialized) {
    throw new Error('The function `usePlugin` should be called before Cherry is instantiated.');
  }
  // ...
}
```

关键发现：
- Cherry 类有静态属性 `initialized`，默认为 `false`
- 创建第一个实例时，constructor 会设置 `Cherry.initialized = true`（见 [cherry.js:68](D:/Downloads/cherry-markdown-cherry-markdown-0.10.3/packages/cherry-markdown/src/cherry.js#L68)）
- `usePlugin()` 必须在实例化之前调用，否则抛出错误

### 2. 原有实现分析

原有代码在 [CherryEditor.vue](src/components/CherryEditor.vue) 中：

```typescript
// 在 initEditor() 内部调用
const initMermaidPlugin = async () => {
  const mermaidModule = await import('mermaid');
  const MermaidCodeEngineModule = await import('cherry-markdown/dist/addons/cherry-code-block-mermaid-plugin.js');
  Cherry.usePlugin(MermaidCodeEngine, { mermaid, mermaidAPI: mermaid });
};

const initEditor = async () => {
  // ...
  if (!mermaidPluginInitialized) {
    await initMermaidPlugin();  // ← 在这里注册插件
    mermaidPluginInitialized = true;
  }
  cherryEditor = new Cherry({...});  // ← 然后创建实例
};
```

**问题根源**：

1. **竞态条件**：`initMermaidPlugin()` 使用 `await import()` 是异步操作
2. **Vue 生命周期**：`onMounted` 可能在多个 CherryEditor 组件中并发触发
3. **执行顺序**：虽然代码上先等待插件再创建实例，但异步操作可能导致时序问题

### 3. 第一次尝试：模块顶层初始化

将插件初始化移到 CherryEditor.vue 的模块顶层：

```typescript
// 在 <script setup> 顶层
const mermaidPluginPromise = (async () => {
  const mermaidModule = await import('mermaid');
  const MermaidCodeEngineModule = await import('cherry-markdown/dist/addons/cherry-code-block-mermaid-plugin.js');
  Cherry.usePlugin(MermaidCodeEngine, { mermaid, mermaidAPI: mermaid });
})();

const initEditor = async () => {
  await mermaidPluginPromise;  // 等待插件注册
  cherryEditor = new Cherry({...});
};
```

**失败原因**：
- 模块顶层的 IIFE 虽然立即开始执行
- 但 `await import()` 仍然是异步的
- 在 Vue 组件挂载的并发场景下，可能出现第一个实例创建时插件还未完成注册

### 4. 第二次尝试：应用启动前初始化（最终方案）

参考 Cherry Markdown 官方示例 [mermaid.html:88-96](D:/Downloads/cherry-markdown-cherry-markdown-0.10.3/examples/mermaid.html#L88-L96)：

```html
<script src="mermaid.min.js"></script>
<script src="cherry-markdown.core.js"></script>
<script src="cherry-code-block-mermaid-plugin.js"></script>
<script>
Cherry.usePlugin(CherryCodeBlockMermaidPlugin, {...});
var config = {...};
var cherryEditor = new Cherry(config);
</script>
```

关键点：**使用同步 `<script>` 标签按顺序加载，确保在实例化前完成插件注册**。

## 解决方案

### 最终架构

在应用启动入口（main.ts）预先注册插件，确保在任何组件使用 Cherry 之前完成。

### 修改文件清单

#### 1. 新建 `src/initCherryPlugins.ts`

创建独立的插件初始化模块：

```typescript
import Cherry from 'cherry-markdown/dist/cherry-markdown.core.js';

let initPromise: Promise<boolean> | null = null;

export async function initCherryPlugins(): Promise<boolean> {
  if (initPromise) {
    return initPromise;
  }

  initPromise = (async () => {
    try {
      const mermaidModule = await import('mermaid');
      const mermaid = (mermaidModule as any).default || mermaidModule;

      const MermaidCodeEngineModule = await import('cherry-markdown/dist/addons/cherry-code-block-mermaid-plugin.js');
      const MermaidCodeEngine = (MermaidCodeEngineModule as any).default || MermaidCodeEngineModule;

      // 检查 Cherry 是否已被实例化
      if (Cherry.initialized) {
        console.error('[initCherryPlugins] Cherry has already been instantiated!');
        return false;
      }

      Cherry.usePlugin(MermaidCodeEngine, {
        mermaid,
        mermaidAPI: mermaid,
      });

      console.log('[initCherryPlugins] Mermaid plugin registered successfully');
      return true;
    } catch (error) {
      console.error('[initCherryPlugins] Failed to initialize mermaid plugin:', error);
      return false;
    }
  })();

  return initPromise;
}
```

**设计要点**：
- ✅ 单例模式：`initPromise` 确保只初始化一次
- ✅ 错误检查：验证 Cherry 未被实例化
- ✅ 模块化：插件初始化逻辑独立于组件

#### 2. 修改 `src/main.ts`

在挂载 Vue 应用前等待插件初始化：

```typescript
import { createApp } from "vue";
import App from "./App.vue";
import "cherry-markdown/dist/cherry-markdown.css";
import "./composables/useTheme";
import { initCherryPlugins } from "./initCherryPlugins";

// 等待插件初始化完成后再挂载应用
async function bootstrap() {
  await initCherryPlugins();
  createApp(App).mount("#app");
}

bootstrap();
```

**执行流程**：
1. 导入 `initCherryPlugins`
2. 调用 `await initCherryPlugins()` → 动态加载并注册 mermaid 插件
3. 插件注册完成后，挂载 Vue 应用
4. Vue 组件中的 Cherry 实例创建时，插件已经注册好

#### 3. 简化 `src/components/CherryEditor.vue`

移除组件内部的插件初始化代码：

```typescript
// 移除了模块顶层的 mermaidPluginPromise
// 移除了 initMermaidPlugin 函数
// 移除了 initEditor() 中的 await mermaidPluginPromise

// 仅保留注释说明
// 注意：mermaid 插件已在 main.ts 中通过 initCherryPlugins() 预先注册
// 不需要在此组件中再次注册
```

#### 4. 修复 `src-tauri/tauri.conf.json` 的 CSP 配置

**问题描述**：
生产构建模式下，Tauri 的 IPC 通信被 CSP 阻止，导致：
- 主题切换失败
- mermaid 样式无法正确应用

**修改前**：
```json
"csp": "default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost data: https:; connect-src 'self' https://api.github.com"
```

**修改后**：
```json
"csp": "default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost data: https:; connect-src 'self' ipc: http://ipc.localhost https:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' 'unsafe-eval'"
```

**CSP 指令说明**：

| 指令 | 新增内容 | 用途 |
|------|---------|------|
| `connect-src` | `ipc: http://ipc.localhost https:` | 允许 Tauri IPC 通信和所有 HTTPS 连接 |
| `style-src` | `'unsafe-inline'` | 允许内联样式（Cherry Markdown 和 mermaid 需要） |
| `script-src` | `'unsafe-inline' 'unsafe-eval'` | 允许动态代码执行（mermaid 等库需要） |

## 技术要点总结

### Cherry Markdown 插件机制

1. **静态方法**：`Cherry.usePlugin()` 是类静态方法，必须在实例化前调用
2. **全局生效**：插件注册后，所有 Cherry 实例共享插件配置
3. **一次性注册**：`PluginClass.$cherry$mounted` 标志防止重复注册

### Vue 3 + 异步初始化模式

```typescript
// ✅ 正确：应用启动前初始化
// main.ts
async function bootstrap() {
  await initPlugins();
  createApp(App).mount("#app");
}

// ❌ 错误：组件内异步初始化
// Component.vue
onMounted(async () => {
  await initPlugin();  // 可能太晚
  new Cherry();
});
```

### Tauri CSP 最佳实践

对于桌面应用：
1. **必须包含 IPC 源**：`ipc: http://ipc.localhost`
2. **合理放宽限制**：
   - `style-src 'unsafe-inline'`：内联样式风险低
   - `script-src 'unsafe-eval'`：桌面应用环境相对安全
3. **按需添加**：根据实际需求添加必要的源

## 测试验证

### 开发模式
```bash
pnpm tauri dev
```

验证点：
- ✅ 控制台无 `usePlugin should be called before Cherry is instantiated` 错误
- ✅ Mermaid 图表正常渲染
- ✅ 主题切换正常

### 生产构建模式
```bash
pnpm tauri build --debug
```

验证点：
- ✅ Mermaid 样式正确显示
- ✅ 无 CSP 相关错误
- ✅ IPC 通信正常
- ✅ 深色/浅色主题切换正常

## 架构优势

### 修改前
```
CherryEditor.vue (组件级)
  ├── onMounted()
  │   ├── initEditor()
  │   │   ├── await initMermaidPlugin()  ← 异步，竞态风险
  │   │   └── new Cherry()
  │   └── ...
```

### 修改后
```
main.ts (应用级)
  ├── bootstrap()
  │   ├── await initCherryPlugins()  ← 同步等待，确保完成
  │   └── createApp(App).mount()
  │       └── CherryEditor.vue
  │           └── new Cherry()  ← 插件已就绪
```

**优势**：
1. ✅ **时序可控**：在应用启动前确保插件就绪
2. ✅ **单一职责**：插件初始化逻辑独立，便于维护
3. ✅ **全局复用**：所有 CherryEditor 组件共享插件配置
4. ✅ **错误隔离**：初始化失败可被捕获和记录

## 相关文档

- [Cherry Markdown 官方 Wiki - Mermaid 集成](https://tencent.github.io/cherry-markdown/examples/mermaid.html)
- [CherryStatic.js 源码](D:/Downloads/cherry-markdown-cherry-markdown-0.10.3/packages/cherry-markdown/src/CherryStatic.js)
- [Mermaid 暗色主题适配记录](../mermaid暗色主题适配记录.md)
- [Word 导出 Mermaid 主题调查报告](../word导出mermaid主题调查报告.md)

## 总结

本次修复通过重构插件初始化流程，将 mermaid 插件注册从组件级提升到应用级，从根本上解决了 Cherry Markdown 插件初始化的时序问题。同时修复了 Tauri CSP 配置，确保生产构建模式下 mermaid 样式正确显示。

**关键经验**：
1. 理解第三方库的插件机制和初始化顺序要求
2. 在应用架构层面处理全局初始化，而非在组件内部
3. 桌面应用需要合理配置 CSP，平衡安全性和功能性
4. 参考官方示例的实践模式，避免反模式
