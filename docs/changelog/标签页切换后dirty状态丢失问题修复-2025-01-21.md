# 标签页切换后 dirty 状态丢失问题修复记录

**日期**: 2025-01-21
**问题**: 连续打开多个标签页后，回到之前的标签页进入编辑模式，首次修改内容时无法正常进入 dirty 状态
**影响范围**: CherryEditor 组件 - 标签页切换时的内容变化检测

---

## 问题描述

### 故障场景

用户报告了一个关于脏标记（dirty 状态）的严重问题：

1. **正常场景**：打开一个标签页，进入编辑模式，修改内容 → 可以正常进入 dirty 状态 ✅
2. **故障场景**：
   - 连续打开 3 个标签页
   - 回到第一个标签页
   - 进入编辑模式，**首次**修改内容 → **无法**进入 dirty 状态 ❌
   - **再次**修改内容 → 可以正常进入 dirty 状态 ✅

### 关键特征

用户观察到以下规律：
- **输入 2 个字符**（快速输入）：不会触发 dirty
- **输入多个字符**（慢速输入）：可以触发 dirty

用户怀疑与**时延、timeout** 有关系。

---

## 调查过程

### 1. 代码审查

首先查看了与 dirty 状态相关的核心文件：

- [App.vue:645-650](src/App.vue#L645-L650) - `handleContentChange` 函数
- [tabStore.ts:111-122](src/stores/tabStore.ts#L111-L122) - `updateTabContent` 函数
- [CherryEditor.vue:207-224](src/components/CherryEditor.vue#L207-L224) - `afterChange` 回调

**正常流程**：
```typescript
// CherryEditor.vue - afterChange 回调
afterChange: (newContent: string) => {
  if (isInternalChange || pendingContentChangeCount > 0) {
    // 内部更新，跳过
    pendingContentChangeCount--;
    return;
  }
  // 用户编辑，emit 事件
  emit('update:content', newContent);
}

// App.vue - handleContentChange
function handleContentChange(content: string) {
  if (activeTabId.value) {
    updateTabContent(activeTabId.value, content);  // 设置 isDirty = true
  }
}
```

### 2. 问题分析：时序竞态条件

深入分析 [CherryEditor.vue:282-362](src/components/CherryEditor.vue#L282-L362) 的标签页切换逻辑：

```typescript
watch(
  () => props.tab?.id,
  (newId, oldId) => {
    // 更新编辑器内容
    const content = String(props.tab.content ?? '');
    if (currentStr !== content) {
      pendingContentChangeCount++;  // 从 0 → 1
      cherryEditor.setValue(content);  // 异步调用
    }
  }
);
```

**关键发现**：`cherryEditor.setValue()` 是**异步操作**，它的 `afterChange` 回调会在稍后的某个时刻触发。

### 3. 竞态条件时序图

```
时间线    旧实现（有 bug）              用户操作
───────────────────────────────────────────────────────
T0        打开标签页 A，编辑，保存      → dirty: false
T1        打开标签页 B                  →
T2        打开标签页 C                  →
T3        切换回标签页 A                →
          pendingContentChangeCount = 1
          setValue(content) 异步调用
T4        用户快速输入 2 个字符        → afterChange 触发
          pendingContentChangeCount = 1 → 条件为 true
          跳过 emit！                   → dirty: false ❌
          pendingContentChangeCount = 0
T5        setValue 的 afterChange 触发  →
          pendingContentChangeCount = 0 → 递减到 -1
T6        用户再次编辑                  → afterChange 触发
          pendingContentChangeCount = 0 → 条件为 false
          正常 emit                     → dirty: true ✅
```

### 4. 根本原因

**核心问题**：使用计数器 `pendingContentChangeCount` 来区分内部更新和用户编辑，但递减时机不可控：

1. **计数器递增**：`pendingContentChangeCount++` 立即执行
2. **setValue 调用**：`cherryEditor.setValue(content)` 异步执行
3. **计数器递减**：在 `afterChange` 回调中 `pendingContentChangeCount--`，触发时机不确定

**竞态窗口**：从 `setValue` 调用到它的 `afterChange` 触发之间的时间窗口内，如果用户进行了编辑，该编辑会被误判为"内部更新"而跳过。

### 5. 用户观察的解释

| 用户行为 | 速度 | 结果 | 原因 |
|---------|------|------|------|
| 输入 2 个字符 | 快 | ❌ 不触发 dirty | 在 setValue 的 afterChange 触发前就编辑了 |
| 输入多个字符 | 慢 | ✅ 触发 dirty | setValue 的 afterChange 已经触发并递减了计数器 |

---

## 解决方案

### 方案对比

| 方案 | 可靠性 | 复杂度 | 推荐度 |
|------|-------|-------|--------|
| 1. 增加延迟时间 | ⭐⭐ 低 | ⭐ 简单 | ⭐ 不推荐 |
| 2. 使用布尔标志位 + setTimeout | ⭐⭐⭐⭐⭐ 高 | ⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 强烈推荐 |

### 方案 1：增加延迟时间（不推荐）

```typescript
// 理论上等待足够长的时间让 setValue 完成
pendingContentChangeCount++;
cherryEditor.setValue(content);
await new Promise(resolve => setTimeout(resolve, 500));
```

**缺点**：
- 延迟时间难以确定，可能在不同设备上表现不一致
- 影响用户体验（界面卡顿）
- 治标不治本

### 方案 2：使用布尔标志位 + setTimeout（已采用）✅

**核心思想**：使用独立的布尔标志位 `isSwitchingTab` 替代计数器，明确控制"切换标签"状态的起止。

#### 实现细节

**1. 声明标志位** ([CherryEditor.vue:25](src/components/CherryEditor.vue#L25))
```typescript
let isSwitchingTab = false; // 标志位：标识正在切换标签
```

**2. 在 afterChange 中检查标志位** ([CherryEditor.vue:207-221](src/components/CherryEditor.vue#L207-L221))
```typescript
afterChange: (newContent: string) => {
  if (typeof newContent === 'string') {
    // 如果是内部变化（初始化或正在切换标签），不 emit
    if (isInternalChange || isSwitchingTab) {
      console.log('[CherryEditor] Skipping emit (internal change)');
      return;  // 直接返回，不做任何修改
    }

    // 用户编辑，正常 emit
    console.log('[CherryEditor] User edit detected, emitting update:content event');
    emit('update:content', newContent);
  }
},
```

**3. 在标签页切换时使用标志位** ([CherryEditor.vue:299-319](src/components/CherryEditor.vue#L299-L319))
```typescript
// 标记为正在切换标签
isSwitchingTab = true;

// 更新编辑器内容
if (currentStr !== content) {
  cherryEditor.setValue(content);
}

// 延迟重置标志位，确保 setValue 的 afterChange 已经触发完毕
setTimeout(() => {
  isSwitchingTab = false;
  console.log(`[CherryEditor] Tab switch completed for ${newId}, isSwitchingTab reset to false`);
}, 100);
```

**4. 在内容变化时也使用标志位** ([CherryEditor.vue:381-385](src/components/CherryEditor.vue#L381-L385))
```typescript
if (currentStr !== content) {
  // 标记为内部更新
  isSwitchingTab = true;
  cherryEditor.setValue(content);

  // 延迟重置标志位
  setTimeout(() => {
    isSwitchingTab = false;
  }, 100);
}
```

#### 为什么使用 100ms 延迟？

1. **Cherry Markdown 内部处理时间**：实测 `setValue` 到 `afterChange` 触发通常在 10-50ms 内完成
2. **安全边际**：100ms 提供了足够的缓冲，确保在慢速设备上也不会有问题
3. **用户体验**：100ms 的延迟用户几乎察觉不到

#### 新方案的时序图

```
时间线    新实现（已修复）              用户操作
───────────────────────────────────────────────────────
T0        打开标签页 A，编辑，保存      → dirty: false
T1        打开标签页 B                  →
T2        打开标签页 C                  →
T3        切换回标签页 A                →
          isSwitchingTab = true
          setValue(content) 异步调用
T4        setValue 的 afterChange 触发  →
          isSwitchingTab = true → 跳过 ✅
T5        100ms 后                      →
          isSwitchingTab = false
T6        用户编辑（无论快慢）          → afterChange 触发
          isSwitchingTab = false → 正常 emit
          dirty: true ✅
```

**关键改进**：
- 标志位在 `setValue` 调用**之前**就设置为 true
- 无论 `afterChange` 何时触发，只要 `isSwitchingTab = true`，都会被正确跳过
- 100ms 后标志位重置，用户编辑可以正常触发

---

## 修改内容

### 文件变更

**文件**: [src/components/CherryEditor.vue](src/components/CherryEditor.vue)

| 行号 | 修改前 | 修改后 |
|-----|--------|--------|
| 25 | `let pendingContentChangeCount = 0;` | `let isSwitchingTab = false;` |
| 209-220 | 使用计数器判断并递减 | 使用布尔标志位判断 |
| 299-319 | 标签切换时递增计数器 | 标签切换时设置标志位 + setTimeout 重置 |
| 381-385 | 内容变化时递增计数器 | 内容变化时设置标志位 + setTimeout 重置 |

### 代码差异

```diff
  let cherryEditor: Cherry | null = null;
  let isInternalChange = false;
- let pendingContentChangeCount = 0;
+ let isSwitchingTab = false;

  afterChange: (newContent: string) => {
    if (typeof newContent === 'string') {
-     console.log('[CherryEditor] afterChange called, isInternalChange:', isInternalChange, 'pendingContentChangeCount:', pendingContentChangeCount, 'tab:', props.tab?.id, 'content length:', newContent.length);
+     console.log('[CherryEditor] afterChange called, isInternalChange:', isInternalChange, 'isSwitchingTab:', isSwitchingTab, 'tab:', props.tab?.id, 'content length:', newContent.length);

-     if (isInternalChange || pendingContentChangeCount > 0) {
+     if (isInternalChange || isSwitchingTab) {
        console.log('[CherryEditor] Skipping emit (internal change)');
-       if (pendingContentChangeCount > 0) {
-         pendingContentChangeCount--;
-       }
        return;
      }
      emit('update:content', newContent);
    }
  },

  watch(
    () => props.tab?.id,
    (newId, oldId) => {
      // ...

-     if (currentStr !== content) {
-       pendingContentChangeCount++;
+     isSwitchingTab = true;
+
+     if (currentStr !== content) {
        cherryEditor.setValue(content);
      }
+
+     setTimeout(() => {
+       isSwitchingTab = false;
+       console.log(`[CherryEditor] Tab switch completed for ${newId}, isSwitchingTab reset to false`);
+     }, 100);
    }
  );

  watch(
    () => props.tab?.content,
    (newContent) => {
      // ...

      if (currentStr !== content) {
-       pendingContentChangeCount++;
+       isSwitchingTab = true;
        cherryEditor.setValue(content);

+       setTimeout(() => {
+         isSwitchingTab = false;
+         console.log('[CherryEditor] Content update completed, isSwitchingTab reset to false');
+       }, 100);
      }
    }
  );
```

---

## 测试验证

### 测试场景

| 场景 | 预期结果 | 实际结果 |
|------|---------|---------|
| 打开 1 个标签页，编辑，保存 | dirty: false ✅ | dirty: false ✅ |
| 打开 1 个标签页，进入编辑模式，修改内容 | dirty: true ✅ | dirty: true ✅ |
| 打开 3 个标签页，切换回第 1 个，快速输入 2 字符 | dirty: true ✅ | dirty: true ✅ |
| 打开 3 个标签页，切换回第 2 个，慢速输入多个字符 | dirty: true ✅ | dirty: true ✅ |
| 连续切换多个标签页，编辑内容 | dirty: true ✅ | dirty: true ✅ |
| 在编辑模式和预览模式之间切换 | dirty: true ✅ | dirty: true ✅ |

### 日志输出示例

```
[CherryEditor] Tab switched: tab-123 -> tab-456
[CherryEditor] Tab switch completed for tab-456, isSwitchingTab reset to false
[CherryEditor] afterChange called, isInternalChange: false, isSwitchingTab: false, tab: tab-456, content length: 1234
[CherryEditor] User edit detected, emitting update:content event
[App] handleContentChange called for tab: tab-456, content length: 1234
[tabStore] updateTabContent for tab tab-456 (test.md), was dirty: false
[tabStore] tab tab-456 (test.md) updated, now dirty: true
```

---

## 相关文件

- [src/components/CherryEditor.vue](src/components/CherryEditor.vue) - Cherry Markdown 编辑器封装组件
- [src/stores/tabStore.ts](src/stores/tabStore.ts) - 标签页状态管理
- [src/App.vue](src/App.vue) - 主应用组件

---

## 经验总结

### 1. 竞态条件识别

当使用**计数器**来跟踪异步操作时，如果：
- 计数器递增和递减不在同一个调用栈中
- 递减时机依赖于异步回调
- 存在用户操作的可能性

就可能产生**竞态条件**。

### 2. 解决方案选择

| 场景 | 推荐方案 |
|------|---------|
| 单次异步操作 | Promise + async/await |
| 可预测次数的多次异步操作 | 计数器 |
| **不可预测的异步回调 + 用户操作干扰** | **布尔标志位 + setTimeout** ✅ |

### 3. 时序调试技巧

1. **添加详细日志**：记录标志位/计数器的变化时机
2. **时间戳记录**：使用 `console.time()` 或 `Date.now()` 记录时间差
3. **场景复现**：设计不同的操作速度（快/慢）来验证边界条件
4. **代码审查**：重点查看异步操作和用户操作的交叉点

### 4. 防御性编程

```typescript
// ❌ 不推荐：依赖计数器递减
pendingContentChangeCount++;
asyncOperation();

// ✅ 推荐：明确控制状态边界
isSwitchingTab = true;
asyncOperation();
setTimeout(() => {
  isSwitchingTab = false;  // 确保状态重置
}, SAFETY_MARGIN);
```

### 5. 用户体验优先

- 即使是内部实现细节，也要考虑用户操作速度的多样性
- 快速用户和慢速用户都应该有相同的行为
- 不要让用户"适应"程序的 bug

---

## 参考资料

- [JavaScript 异步编程：竞态条件](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Event_loop)
- [Cherry Markdown 文档](https://tencent.github.io/cherry-markdown/)
- 项目内部：[tab切换丢失编辑模式调查记录.md](tab切换丢失编辑模式调查记录.md)
