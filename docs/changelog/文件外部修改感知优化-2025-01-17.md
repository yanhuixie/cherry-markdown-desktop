# 文件外部修改感知优化 - 2025-01-17

## 初始问题

用户反馈：当应用自己保存文件时，也会触发"文件被外部修改"的提示对话框，要求用户选择是否重新加载。这是不合理的，因为文件是应用自己修改的，不应该提示用户。

## 问题分析

### 当前实现

在 `src/App.vue` 中，文件外部修改感知功能的实现方式：

1. **文件监视**（525-564行）：使用 `@tauri-apps/plugin-fs` 的 `watch()` API 监视当前活动标签的文件
2. **变化检测**：当文件发生变化时，触发回调并显示 `FileReloadDialog` 对话框
3. **防抖延迟**：设置了 500ms 的防抖延迟（`delayMs: 500`）

### 问题根源

应用保存文件的操作流程：
1. 用户点击"保存"按钮
2. 调用 `writeTextFile()` 写入文件
3. 文件系统检测到文件变化
4. 触发 `watch()` 的回调
5. 显示"文件被外部修改"对话框

**核心问题**：保存操作没有排除在文件监视之外，导致应用自身的保存也被当作"外部修改"。

## 解决方案

采用**标志位方案**：添加 `isSavingFile` 变量来标识当前是否正在保存文件，在文件监视回调中检查该标志位，如果是应用自己保存的则忽略。

### 方案对比

| 方案 | 描述 | 优点 | 缺点 | 选择 |
|------|------|------|------|------|
| 方案一 | 添加 `isSavingFile` 标志位 | 简单可靠，逻辑清晰 | 需要在所有保存位置添加标志位控制 | ✅ 采用 |
| 方案二 | 保存前停止监视，保存后重启 | 实现简单 | 有竞态问题，可能导致遗漏文件变化 | ❌ 不采用 |

## 实现细节

### 1. 添加标志位变量

**修改文件**：`src/App.vue`

```javascript
let isSavingFile = false; // 标志位：标识当前是否正在保存文件（用于区分自身保存和外部修改）
```

### 2. 文件监视回调检查标志位

**修改文件**：`src/App.vue` (540-567行)

```javascript
unwatchFn = await watchFile(
  filePath,
  async (event) => {
    console.log('[App] File changed:', event, filePath, 'isSavingFile:', isSavingFile);

    // 如果是应用自己保存的，忽略此次变化
    if (isSavingFile) {
      console.log('[App] File change caused by self-save, ignoring');
      return;
    }

    // 动态查找当前文件对应的 tab（避免闭包捕获旧对象）
    const currentTab = tabs.find(t => t.filePath === filePath);
    if (!currentTab) {
      console.log('[App] Tab not found, ignoring file change');
      return;
    }

    // 显示重新加载对话框
    console.log('[App] Showing reload dialog for user confirmation');
    pendingReloadFileName.value = currentTab.fileName;
    pendingReloadFilePath.value = filePath;
    pendingReloadHasUnsavedChanges.value = currentTab.isDirty;
    showFileReloadDialog.value = true;
  },
  {
    delayMs: 500, // 防抖延迟 500ms
  }
);
```

### 3. 保存操作封装

在所有保存文件的位置添加标志位控制：

#### 3.1 `handleSave()` - 常规保存

**修改文件**：`src/App.vue` (286-307行)

```javascript
async function handleSave() {
  const tab = activeTab.value;
  if (!tab) return;

  if (!tab.filePath || tab.filePath.startsWith('untitled')) {
    handleSaveAs();
    return;
  }

  isSavingFile = true; // 标记正在保存
  try {
    await writeTextFile(tab.filePath, tab.content);
    markTabSaved(tab.id);
    // 延迟清除标志位，确保文件监视的防抖延迟已过
    setTimeout(() => {
      isSavingFile = false;
    }, 600);
  } catch (error) {
    isSavingFile = false;
    throw error;
  }
}
```

#### 3.2 `handleSaveAs()` - 另存为

**修改文件**：`src/App.vue` (309-333行)

```javascript
async function handleSaveAs() {
  const tab = activeTab.value;
  if (!tab) return;

  const filePath = await save({
    filters: [{ name: 'Markdown', extensions: ['md', 'markdown'] }],
  });

  if (filePath) {
    isSavingFile = true; // 标记正在保存
    try {
      await writeTextFile(filePath, tab.content);
      tab.filePath = filePath;
      tab.fileName = filePath.split(/[/\\]/).pop() || filePath;
      markTabSaved(tab.id);
      // 延迟清除标志位，确保文件监视的防抖延迟已过
      setTimeout(() => {
        isSavingFile = false;
      }, 600);
    } catch (error) {
      isSavingFile = false;
      throw error;
    }
  }
}
```

#### 3.3 窗口关闭时保存

**修改文件**：`src/App.vue` (145-182行)

```javascript
} else if (choice === 'save') {
  // 保存文件
  console.log('[App] User chose to save');
  isSavingFile = true; // 标记正在保存
  try {
    if (tab.filePath && !tab.filePath.startsWith('untitled')) {
      await writeTextFile(tab.filePath, tab.content);
      markTabSaved(tab.id);
    } else {
      // 未命名文件，需要另存为
      const filePath = await save({
        filters: [{ name: 'Markdown', extensions: ['md', 'markdown'] }],
      });
      if (!filePath) {
        // 用户取消了另存为，停止关闭流程
        console.log('[App] User cancelled save as, stopping close');
        isSavingFile = false;
        pendingCloseTabId.value = null;
        pendingCloseFileName.value = '';
        showUnsavedChangesDialog.value = false;
        return;
      }
      await writeTextFile(filePath, tab.content);
      tab.filePath = filePath;
      tab.fileName = filePath.split(/[/\\]/).pop() || filePath;
      markTabSaved(tab.id);
    }
    // 延迟清除标志位
    setTimeout(() => {
      isSavingFile = false;
    }, 600);
  } catch (error) {
    isSavingFile = false;
    throw error;
  }
  pendingCloseTabId.value = null;
  pendingCloseFileName.value = '';
  showUnsavedChangesDialog.value = false;
}
```

#### 3.4 标签页关闭时保存

**修改文件**：`src/App.vue` (391-441行)

```javascript
switch (choice) {
  case 'save':
    // 保存文件然后关闭标签页
    console.log('[App] Saving tab:', tab.fileName);
    isSavingFile = true; // 标记正在保存
    try {
      if (tab.filePath && !tab.filePath.startsWith('untitled')) {
        await writeTextFile(tab.filePath, tab.content);
        markTabSaved(tab.id);
      } else {
        // 未命名文件，需要另存为
        const filePath = await save({
          filters: [{ name: 'Markdown', extensions: ['md', 'markdown'] }],
        });
        if (filePath) {
          await writeTextFile(filePath, tab.content);
          tab.filePath = filePath;
          tab.fileName = filePath.split(/[/\\]/).pop() || filePath;
          markTabSaved(tab.id);
        } else {
          // 用户取消了另存为，不关闭标签页
          console.log('[App] User cancelled save as');
          isSavingFile = false;
          showUnsavedChangesDialog.value = false;
          pendingCloseTabId.value = null;
          pendingCloseFileName.value = '';
          return;
        }
      }
      // 延迟清除标志位
      setTimeout(() => {
        isSavingFile = false;
      }, 600);
    } catch (error) {
      isSavingFile = false;
      throw error;
    }
    closeTab(tabId);
    showUnsavedChangesDialog.value = false;
    break;
  // ...
}
```

## 关键设计点

### 1. 延迟时间选择

使用常量定义延迟时间（src/App.vue:17-18）：

```javascript
const FILE_WATCH_DEBOUNCE_MS = 500; // 文件监视的防抖延迟（毫秒）
const SAVE_FLAG_CLEAR_DELAY_MS = FILE_WATCH_DEBOUNCE_MS + 100; // 保存标志位清除延迟（比防抖延迟多 100ms 确保安全）
```

- 文件监视的防抖延迟：`FILE_WATCH_DEBOUNCE_MS = 500ms`
- 标志位清除延迟：`SAVE_FLAG_CLEAR_DELAY_MS = 600ms`（防抖延迟 + 100ms 缓冲）

**原因**：确保在文件监视的防抖延迟期间，标志位仍然为 `true`，防止因异步时序问题导致误判。

**优势**：使用常量而不是魔术数字，使代码更易维护和修改。

### 2. 错误处理

所有保存操作都使用 `try-catch` 包裹：
- 保存成功：延迟 600ms 后清除标志位
- 保存失败或用户取消：立即清除标志位

### 3. 日志增强

在文件监视回调中添加了 `isSavingFile` 的日志输出，方便调试：

```javascript
console.log('[App] File changed:', event, filePath, 'isSavingFile:', isSavingFile);
```

## 关键文件修改清单

### src/App.vue

**新增变量**：
- 第 22 行：`let isSavingFile = false;`

**修改函数**：
- `handleSave()` (286-307行)：添加标志位控制
- `handleSaveAs()` (309-333行)：添加标志位控制
- 窗口关闭事件处理 (145-182行)：添加标志位控制
- `handleUnsavedChangesChoice()` (391-441行)：添加标志位控制

**修改文件监视回调**：
- `startWatchingFile()` 内的 watch 回调 (540-567行)：检查 `isSavingFile` 标志位

## 测试验证

### 测试场景

1. **正常保存**：保存文件后，不应出现"文件被外部修改"提示 ✅
2. **另存为**：另存为新文件后，不应出现提示 ✅
3. **关闭时保存**：关闭窗口/标签页并保存后，不应出现提示 ✅
4. **外部修改**：用其他编辑器修改文件后，应正常显示提示 ✅

### 验证方法

1. 打开一个 Markdown 文件
2. 修改内容
3. 点击保存按钮
4. 观察：不应该出现"文件被外部修改"的对话框
5. 用其他编辑器（如 VS Code）修改同一个文件
6. 观察：应该出现"文件被外部修改"的对话框

## 经验教训

1. **文件监视的陷阱**：文件监视 API 会检测到所有文件变化，包括应用自身的修改。需要正确区分"内部修改"和"外部修改"。

2. **标志位时序问题**：使用 `setTimeout` 延迟清除标志位时，延迟时间必须大于文件监视的防抖延迟，否则可能因异步时序问题导致误判。

3. **全局状态管理**：`isSavingFile` 是模块级别的全局变量，在整个应用的生命周期内共享。需要确保在所有保存操作路径上都正确设置和清除标志位。

4. **错误处理的重要性**：在异步操作中，必须考虑错误情况和用户取消操作，确保标志位能够正确重置，避免影响后续操作。

5. **日志的作用**：在关键的判断逻辑处添加日志输出，能够极大地帮助调试和问题定位。

## 参考资料

- Tauri 2.x 文档：`@tauri-apps/plugin-fs` 的 `watch()` API
- 项目文档：`d:\develop\runlefei\CherryMarkdownDesktop\CLAUDE.md`
- 相关文档：`d:\develop\runlefei\CherryMarkdownDesktop\docs\tab切换丢失编辑模式调查记录.md`（标志位使用参考）
