# 字号切换功能实现 - 2025-01-18

## 需求背景

用户需要在工具栏中添加字号切换功能，能够实时调整编辑器的字体大小，提供"中"、"大"、"超大"三个档位。同时需要确保目录（TOC）组件不受字体大小变化影响，避免在大字体下变得拥挤。

## 技术调研

### Cherry Markdown 字体系统

通过调查 `D:\Downloads\cherry-markdown-cherry-markdown-0.10.3\` 源代码，发现 Cherry Markdown 使用 CSS 变量控制字体大小：

```scss
:root {
  --font-size-xs: 12px;
  --font-size-sm: 14px;
  --font-size-md: 16px;  // 默认字体大小
  --font-size-lg: 18px;
  --font-size-xl: 20px;
  --font-size-2xl: 24px;
  --font-size-3xl: 30px;
}
```

### TOC 组件字体问题

调查发现 `.cherry-flex-toc` 组件使用通用的 `--font-size-md` 变量，没有专门的字体变量。如果直接修改主字体变量，TOC 也会跟着变大，导致拥挤。

## 解决方案

### 架构设计

采用 **Composable + 自定义事件** 的架构：

1. **`useFontSize` Composable**：管理字体大小状态，持久化存储，触发更新事件
2. **Toolbar 组件**：提供 UI 交互，调用 composable 切换字号
3. **CherryEditor 组件**：监听事件，动态更新 CSS 变量

### 字号配置

| 级别 | 基准字体 | 倍数 | TOC 标题 | TOC 项目 |
|------|----------|------|----------|----------|
| 中 | 16px | 1x | 15px | 14px |
| 大 | 20px | 1.25x | 15px | 14px |
| 超大 | 32px | 2x | 15px | 14px |

**设计思路**：
- 主文本字体按倍数放大，满足阅读需求
- TOC 字体保持固定（14-15px），避免拥挤

## 实现细节

### 1. 创建 `useFontSize` Composable

**新建文件**：`src/composables/useFontSize.ts`

```typescript
import { ref, watch } from 'vue';

export type FontSizeLevel = 'medium' | 'large' | 'xlarge';

const FONT_SIZE_CONFIGS = {
  medium: {
    label: '中',
    multiplier: 1,
    sizes: {
      xs: '12px', sm: '14px', md: '16px', lg: '18px',
      xl: '20px', '2xl': '24px', '3xl': '30px',
    },
    tocSizes: { title: '15px', item: '14px' },
  },
  large: {
    label: '大',
    multiplier: 1.25,
    sizes: {
      xs: '15px', sm: '18px', md: '20px', lg: '23px',
      xl: '25px', '2xl': '30px', '3xl': '38px',
    },
    tocSizes: { title: '15px', item: '14px' },
  },
  xlarge: {
    label: '超大',
    multiplier: 2,
    sizes: {
      xs: '24px', sm: '28px', md: '32px', lg: '36px',
      xl: '40px', '2xl': '48px', '3xl': '60px',
    },
    tocSizes: { title: '15px', item: '14px' },
  },
} as const;

const STORAGE_KEY = 'cherry-font-size';
const storedFontSize = localStorage.getItem(STORAGE_KEY) as FontSizeLevel | null;
const currentFontSize = ref<FontSizeLevel>(storedFontSize || 'medium');

watch(currentFontSize, (newValue) => {
  localStorage.setItem(STORAGE_KEY, newValue);
  window.dispatchEvent(new CustomEvent('font-size-changed', {
    detail: { level: newValue }
  }));
});

export function useFontSize() {
  const setFontSize = (level: FontSizeLevel) => {
    currentFontSize.value = level;
  };

  const getSizes = () => FONT_SIZE_CONFIGS[currentFontSize.value].sizes;
  const getTocSizes = () => FONT_SIZE_CONFIGS[currentFontSize.value].tocSizes;

  return {
    currentFontSize,
    setFontSize,
    getSizes,
    getTocSizes,
    FONT_SIZE_CONFIGS,
  };
}
```

**关键点**：
- 使用 `localStorage` 持久化用户选择
- 使用 `CustomEvent` 通知编辑器更新
- 提供 `getSizes()` 和 `getTocSizes()` 分别获取主字体和 TOC 字体配置

### 2. Toolbar 添加字号选择按钮

**修改文件**：`src/components/Toolbar.vue`

#### 2.1 导入 composable

```typescript
import { useFontSize } from '../composables/useFontSize';
const { currentFontSize, setFontSize, FONT_SIZE_CONFIGS } = useFontSize();
```

#### 2.2 添加 UI 组件

在"亮色/暗色"按钮后添加：

```vue
<!-- 字号选择按钮 -->
<div class="font-size-menu-container">
  <button
    ref="fontSizeMenuButton"
    class="toolbar-btn"
    @click="toggleFontSizeMenu"
    :class="{ 'active': showFontSizeMenu }"
  >
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M4 7V4h16v3" />
      <path d="M9 20h6" />
      <path d="M12 4v16" />
    </svg>
    字号
  </button>

  <!-- 字号下拉菜单 -->
  <div v-if="showFontSizeMenu" class="font-size-dropdown">
    <div class="font-size-title">选择字号</div>
    <div class="font-size-options">
      <button
        v-for="(config, key) in FONT_SIZE_CONFIGS"
        :key="key"
        class="font-size-option"
        :class="{ 'selected': currentFontSize === key }"
        @click="selectFontSize(key as 'medium' | 'large' | 'xlarge')"
      >
        <span class="font-size-label">{{ config.label }}</span>
        <span class="font-size-preview" :style="{ fontSize: config.sizes.md }">A</span>
      </button>
    </div>
  </div>
</div>
```

#### 2.3 添加交互逻辑

```typescript
// 字号下拉菜单状态
const showFontSizeMenu = ref(false);
const fontSizeMenuButton = ref<HTMLButtonElement | null>(null);

function toggleFontSizeMenu() {
  showFontSizeMenu.value = !showFontSizeMenu.value;
}

function selectFontSize(level: 'medium' | 'large' | 'xlarge') {
  setFontSize(level);
  showFontSizeMenu.value = false;
}

// 点击外部关闭菜单
function handleClickOutside(event: MouseEvent) {
  if (fontSizeMenuButton.value && !fontSizeMenuButton.value.contains(event.target as Node)) {
    showFontSizeMenu.value = false;
  }
}
```

#### 2.4 添加样式

```css
/* 字号菜单容器 */
.font-size-menu-container {
  position: relative;
}

.font-size-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 4px;
  min-width: 200px;
  background-color: #fff;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  overflow: hidden;
}

.font-size-title {
  padding: 10px 12px 8px;
  font-size: 12px;
  font-weight: 600;
  color: #666;
  border-bottom: 1px solid #eee;
}

.font-size-options {
  display: flex;
  flex-direction: column;
  padding: 4px;
}

.font-size-option {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: none;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.15s;
}

.font-size-option:hover {
  background-color: #f0f0f0;
}

.font-size-option.selected {
  background-color: #e8f4fd;
  font-weight: 600;
}

.font-size-label {
  font-size: 13px;
  color: #333;
}

.font-size-preview {
  font-size: 16px;
  color: #666;
  font-weight: bold;
}
```

**暗色主题适配**：

```css
html.dark .font-size-dropdown {
  background-color: #3c3c3c;
  border-color: #4a4a4a;
}

html.dark .font-size-title {
  color: #999;
  border-bottom-color: #4a4a4a;
}

html.dark .font-size-option:hover {
  background-color: #4a4a4a;
}

html.dark .font-size-option.selected {
  background-color: #1e4d6b;
}

html.dark .font-size-label {
  color: #d4d4d4;
}

html.dark .font-size-preview {
  color: #999;
}
```

### 3. CherryEditor 动态更新字体

**修改文件**：`src/components/CherryEditor.vue`

#### 3.1 导入 composable

```typescript
import { useFontSize, type FontSizeLevel } from '../composables/useFontSize';
const { getSizes, getTocSizes } = useFontSize();
```

#### 3.2 实现 updateFontSizes 函数

```typescript
// 更新 Cherry Markdown 的 CSS 字体变量
const updateFontSizes = () => {
  const sizes = getSizes();
  const tocSizes = getTocSizes();

  // 查找 Cherry Markdown 的容器元素
  const cherryContainer = editorRef.value?.querySelector('.cherry') as HTMLElement;
  if (cherryContainer) {
    // 设置主字体大小变量
    cherryContainer.style.setProperty('--font-size-xs', sizes.xs);
    cherryContainer.style.setProperty('--font-size-sm', sizes.sm);
    cherryContainer.style.setProperty('--font-size-md', sizes.md);
    cherryContainer.style.setProperty('--font-size-lg', sizes.lg);
    cherryContainer.style.setProperty('--font-size-xl', sizes.xl);
    cherryContainer.style.setProperty('--font-size-2xl', sizes['2xl']);
    cherryContainer.style.setProperty('--font-size-3xl', sizes['3xl']);

    // 设置 TOC 字体大小（避免 TOC 拥挤）
    const tocContainer = cherryContainer.querySelector('.cherry-flex-toc') as HTMLElement;
    if (tocContainer) {
      tocContainer.style.fontSize = tocSizes.item;
    }
    const tocTitle = cherryContainer.querySelector('.cherry-toc-title') as HTMLElement;
    if (tocTitle) {
      tocTitle.style.fontSize = tocSizes.title;
    }

    console.log('[CherryEditor] Font sizes updated:', sizes, 'TOC sizes:', tocSizes);
  }
};
```

#### 3.3 监听字体变化事件

```typescript
// 监听字体大小变化事件
const handleFontSizeChange = (event: Event) => {
  const customEvent = event as CustomEvent<{ level: FontSizeLevel }>;
  console.log('[CherryEditor] Font size changed to:', customEvent.detail.level);
  updateFontSizes();
};
```

#### 3.4 生命周期钩子

```typescript
onMounted(() => {
  initEditor();
  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('font-size-changed', handleFontSizeChange);
});

onBeforeUnmount(() => {
  if (cherryEditor) {
    cherryEditor.destroy();
  }
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('font-size-changed', handleFontSizeChange);
});
```

#### 3.5 初始化时应用字体大小

在 Cherry 编辑器的 `afterInit` 回调中：

```typescript
afterInit: () => {
  console.log('Cherry Editor initialized');
  isInternalChange = false;
  // 应用初始字体大小
  setTimeout(() => {
    updateFontSizes();
  }, 0);
},
```

## 关键设计点

### 1. TOC 字体问题的解决方案

**问题**：直接设置 `.cherry-toc-one-a` 元素的字体大小无效。

**原因**：
- TOC 可能是动态创建的，设置时元素不存在
- 可能有更高优先级的样式覆盖

**解决方案**：直接在 `.cherry-flex-toc` 容器上设置字体大小

```typescript
const tocContainer = cherryContainer.querySelector('.cherry-flex-toc') as HTMLElement;
if (tocContainer) {
  tocContainer.style.fontSize = tocSizes.item;
}
```

**优势**：
- 所有子元素自动继承字体大小
- 不受动态创建影响
- 代码简洁（只需设置一个元素）

### 2. 事件驱动架构

使用 `CustomEvent` 实现组件间通信：

```
Toolbar (用户交互) → useFontSize (状态管理) → CustomEvent → CherryEditor (更新样式)
```

**优势**：
- 组件解耦，Toolbar 不直接依赖 CherryEditor
- 状态集中管理，易于维护
- 支持多个组件同时监听（如需要）

### 3. 持久化存储

使用 `localStorage` 保存用户选择：

```typescript
const STORAGE_KEY = 'cherry-font-size';
const storedFontSize = localStorage.getItem(STORAGE_KEY) as FontSizeLevel | null;
const currentFontSize = ref<FontSizeLevel>(storedFontSize || 'medium');

watch(currentFontSize, (newValue) => {
  localStorage.setItem(STORAGE_KEY, newValue);
  // ...
});
```

**优势**：
- 用户设置在重启应用后仍然保留
- 默认值为 'medium'，符合 Cherry Markdown 原始配置

### 4. CSS 变量的动态设置

使用 `style.setProperty()` 动态修改 CSS 变量：

```typescript
cherryContainer.style.setProperty('--font-size-md', sizes.md);
```

**优势**：
- 无需重新创建编辑器
- 实时生效，无需刷新
- 利用 Cherry Markdown 现有的 CSS 变量系统

## 关键文件修改清单

### 新建文件

- `src/composables/useFontSize.ts` - 字体大小状态管理

### 修改文件

#### `src/components/Toolbar.vue`

**新增**：
- 导入 `useFontSize`
- 字号下拉菜单 UI（156-188行）
- 交互逻辑（32-41行）
- 样式（270-341行）

#### `src/components/CherryEditor.vue`

**新增**：
- 导入 `useFontSize` 和 `FontSizeLevel` 类型（第6行）
- `updateFontSizes()` 函数（26-56行）
- `handleFontSizeChange()` 事件监听器（58-63行）
- 生命周期钩子中添加事件监听（387-403行）
- `afterInit` 中应用初始字体（183-191行）

## 测试验证

### 测试场景

1. **基本切换**：在三个档位之间切换，字体实时变化 ✅
2. **持久化**：重启应用后，字号设置保持不变 ✅
3. **TOC 不受影响**：大字体下，TOC 仍然保持紧凑 ✅
4. **亮色/暗色主题**：两种主题下都正常显示 ✅
5. **预览实时生效**：切换字号后，预览区域立即更新 ✅

### 验证方法

1. 启动应用：`pnpm tauri dev`
2. 点击工具栏"字号"按钮
3. 依次选择"中"、"大"、"超大"
4. 观察：
   - 主文本字体是否变化
   - TOC 是否保持紧凑
   - 下拉菜单是否正确显示当前选中状态
5. 重启应用，验证字号设置是否保持

## 经验教训

### 1. Cherry Markdown 的 CSS 变量系统

Cherry Markdown 使用 CSS 变量控制样式，这是官方推荐的定制方式。通过修改 CSS 变量而不是覆盖样式，可以保持与主题系统的兼容性。

### 2. TOC 组件的特殊性

TOC 组件没有独立的字体变量，需要单独处理。直接在容器上设置字体大小比逐个设置子元素更优雅、更可靠。

### 3. 事件驱动架构的优势

使用 `CustomEvent` 实现组件间通信，避免了组件间的直接依赖，提高了代码的可维护性和可扩展性。

### 4. 持久化存储的重要性

用户偏好设置应该持久化存储，避免每次重启应用后需要重新设置。`localStorage` 是简单有效的方案。

### 5. 下拉菜单的 UX 设计

- 点击外部自动关闭菜单
- 当前选中项高亮显示
- 实时预览字体大小（"A"字示例）
- 支持键盘导航（可扩展）

## 改进空间

### 1. 键盘快捷键

可以为字号切换添加键盘快捷键，例如：
- `Ctrl + Plus`：增大字号
- `Ctrl + Minus`：减小字号
- `Ctrl + 0`：重置为默认字号

### 2. 自定义字号

目前只提供三个档位，可以增加"自定义"选项，让用户输入具体的像素值。

### 3. 字号预览

可以在下拉菜单中显示更大段的示例文本，让用户更好地预览效果。

### 4. 不同元素独立配置

目前所有元素使用相同的字体倍数，可以考虑让用户单独配置标题、正文、代码块的字体大小。

## 参考资料

- Cherry Markdown 源代码：`D:\Downloads\cherry-markdown-cherry-markdown-0.10.3\`
- Cherry Markdown CSS 变量：`packages/cherry-markdown/src/sass/variables/base.scss`
- Vue 3 Composables：https://vuejs.org/guide/reusability/composables.html
- Web CustomEvent API：https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
- 项目文档：`d:\develop\runlefei\CherryMarkdownDesktop\CLAUDE.md`
